{
module "IscsiClientLib";
textdomain "iscsi-client";

import "Service";
import "Popup";
import "Hostname";
import "Stage";
import "ModuleLoading";
import "Mode";
import "String";
import "Arch";

global list <string> sessions = [];
global list <string> discovered = [];
global list <string> targets = [];
global list<string> currentRecord = [];
map<string,string> iface_file = $[];
list<string> iface_eth = []; 

// status of rcopen-iscsi service
boolean serviceStatus = false;
// main configuration file (/etc/iscsi/iscsid.conf)
map<string, any> config = $[];
// iBFT (iSCSI Boot Firmware Table)
map<string, any> ibft = nil;
// InitiatorName file (/etc/iscsi/initiatorname.iscsi)
global string initiatorname = "";
// map used for autoYaST
global map ay_settings=nil;
// interface type for hardware offloading
string offload_card = "default";

string offboard_script = "iscsi_offload";

void CallConfigScript();

global string GetOffloadCard()
    {
    return( offload_card );
    }

global void SetOffloadCard( string new_card )
    {
    y2milestone( "SetOffloadCard:%1 cur:%2", new_card, offload_card );
    if( new_card != offload_card )
	{
	offload_card = new_card;
	if( new_card != "default" )
	    CallConfigScript();
	}
    }

global string GetAdmCmd( string params )
    {
    string ret = "iscsiadm";
    ret = ret + " " + params;
    y2milestone( "GetAdmCmd:%1", ret );
    return( ret );
    }

global map<string, any> hidePassword(map<string, any> orig){
 map<string, any> hidden=$[];
 foreach(string key, any value, orig, {
  if (issubstring(key, "PASS")) value="*****";
  hidden[key]=value;
 });
 return hidden;
}


/**
 * get iBFT (available only on some special hardware)
 */
global map<string, any> getiBFT(){
 if (ibft==nil){
  if (!Arch::i386() && !Arch::x86_64()){
	y2milestone("Because architecture %1 is is different from x86, not using iBFT", Arch::arch_short());
	 return $[];
 }
  ibft=$[];
  y2milestone("check and modprobe iscsi_ibft : %1", SCR::Execute(.target.bash_output, "lsmod |grep -q iscsi_ibft || modprobe iscsi_ibft"));
  string from_bios = ((map<string, any>)SCR::Execute(.target.bash_output, GetAdmCmd("-m fw")))["stdout"]:"";
  foreach(string row, splitstring(from_bios, "\n"), {
   list<string> key_val=splitstring(row, "=");
//   if (size(key_val[0]:"")>0) ibft[key_val[0]:""] = key_val[1]:"";
   string kv = String::CutBlanks(key_val[0]:"");
   if (size(kv) > 0) ibft[kv] = String::CutBlanks(key_val[1]:"");
  });
 }
 y2milestone("iBFT %1", hidePassword(ibft));
 return ibft;
}


// get accessor for service status
global boolean GetStartService() {
 boolean status = Service::Enabled("open-iscsi");
 y2milestone("Status of open-iscsi %1", status);
 return status;
}

// set accessor for service status
global void SetStartService(boolean status) {
 y2milestone("Set status of open-iscsi to %1", status);
 if (status == true) {
    Service::Enable("boot.open-iscsi");
    Service::Enable("open-iscsi");
 } else {
    Service::Disable("boot.open-iscsi");
    Service::Disable("open-iscsi");
 }
}


// read configuration file
global list <map<string, any> > getConfig(){
 // use cache if available
 if (size(config)==0){
  config = (map<string, any>) SCR::Read(.etc.iscsid.all);
  y2debug("read config %1", config);
 }
 return config["value"]:[];
}

global void setConfig(list new_config){
 config["value"]=new_config;
}

// do we use iSNS for targets?
global boolean useISNS(){
 boolean use = false;
 foreach(map<string, any> row, getConfig(), {
  if (row["name"]:""=="isns.address" || row["name"]:""=="isns.port") {
	 use = true;
	}
 });
 return use;
}


// write temporary changed old config
global void oldConfig(){
 y2milestone("Store temporary config %1", config);
 SCR::Write(.etc.iscsid.all, config);
 SCR::Write(.etc.iscsid, nil);
}


global map<string, any> getNode(){
  string cmdline = GetAdmCmd(sformat( "-S -m node -I %3 -T %1 -p %2", currentRecord[1]:"", currentRecord[0]:"", currentRecord[2]:"default" ));
  map<string, any> cmd = (map<string, any>)SCR::Execute(.target.bash_output, cmdline);
 if (cmd["exit"]:0!=0) return $[];
 map<string, any> auth = $[];
 foreach(string row, splitstring(cmd["stdout"]:"", "\n"), {
 string key = splitstring(row," = ")[0]:"";
 string val = splitstring(row," = ")[3]:"";
 if(val == "<empty>") val="";
  switch(key){
   case("node.session.auth.authmethod"):
		auth["authmethod"]=val;
		break;
   case("node.session.auth.username"):
		auth["username"]=val;
		break;
   case("node.session.auth.password"):
		auth["password"]=val;
		break;
   case("node.session.auth.username_in"):
		auth["username_in"]=val;
		break;
   case("node.session.auth.password_in"):
		auth["password_in"]=val;
		break;
  }
 });
 return auth;
}

// create map from given map in format needed by ini-agent
map<string, any> createMap(map<string, any> old_map, list<string> comments)
{
 string comment = "";
 foreach(string row, comments, {
  comment = sformat("%1%2", comment, row);
  });
 return $[ "name":old_map["KEY"]:"",
           "value":old_map["VALUE"]:"",
           "kind":"value",
           "type":1,
           "comment":comment
         ];
}

// add or modify given map
list <map<string, any> > setOrAdd(list <map<string, any> > old_list, string key, string value){
 list <map<string, any> > new_list = [];
 boolean found = false;
 foreach(map<string, any> row, old_list, {
  if (row["name"]:"" == key){
   found = true;
   row["value"] = value;
  }
  new_list = add(new_list, row);
 });
 if (!found) new_list = add(new_list, createMap($["KEY":key, "VALUE":value], []) );
 return new_list;
}

// delete record with given key
list <map<string, any> > delete(list <map<string, any> > old_list, string key){
 y2milestone("Delete record for %1", key);
 list <map<string, any> > new_list = [];
 foreach(map<string, any> row, old_list, {
  if (row["name"]:"" != key) new_list = add(new_list, row);
 });
 return new_list;
}

// temporary change config for discovery authentication
global void saveConfig(string user_in, string pass_in, string user_out, string pass_out){
 y2milestone("Save config");
 map<string, any> tmp_conf = config;
 list <map<string, any> > tmp_val = tmp_conf["value"]:[];

 if ((size(user_in)>0)&&(size(pass_in)>0)) {
	tmp_val = setOrAdd(tmp_val, "node.session.auth.username", user_in);
	tmp_val = setOrAdd(tmp_val, "node.session.auth.password", pass_in);
	}
  else {
	tmp_val = delete(tmp_val, "node.session.auth.username");
	tmp_val = delete(tmp_val, "node.session.auth.password");
	}

 if ((size(user_out)>0)&&(size(pass_out)>0)) {
	tmp_val = setOrAdd(tmp_val, "discovery.sendtargets.auth.authmethod", "CHAP");
	tmp_val = setOrAdd(tmp_val, "discovery.sendtargets.auth.username", user_out);
	tmp_val = setOrAdd(tmp_val, "discovery.sendtargets.auth.password", pass_out);
	}
  else {
	tmp_val = delete(tmp_val, "discovery.sendtargets.auth.authmethod");
	tmp_val = delete(tmp_val, "discovery.sendtargets.auth.username");
	tmp_val = delete(tmp_val, "discovery.sendtargets.auth.password");
	}
 tmp_conf["value"] = tmp_val;
 SCR::Write(.etc.iscsid.all, tmp_conf);
 SCR::Write(.etc.iscsid, nil);
}

global list<string> ScanDiscovered( list<string> data )
    {
    list<string> ret = [];
    string target = "";
    string portal = "";
    string iface = "";
    foreach( string row, data,
	{
	row = deletechars(row,"\t");
	if( search(row,"Target:")!=nil )
	    target = splitstring(row, " ")[1]:"";
	else if( search(row,"Portal:")!=nil )
	    {
	    if( search(row,"Current Portal:")!=nil )
		portal = splitstring(row, " ")[2]:"";
	    else if( search(row,"Persistent Portal:")==nil )
		portal = splitstring(row, " ")[1]:"";
	    }
	else if( search(row,"Iface Name:")!=nil )
	    {
	    iface = splitstring(row, " ")[2]:"";
	    iface = iface_file[iface]:iface;
	    if( findfirstof( portal, "[]" )==nil )
		ret = add(ret, portal + " " + target + " " + iface);
	    }
	});
    y2milestone( "ScanDiscovered ret:%1", ret );
    return( ret );
    }

// get all discovered targets
global list<string> getDiscovered()
    {
	 discovered=[];
    map<string, any> retcode = (map<string, any>)SCR::Execute(.target.bash_output, GetAdmCmd("-m node -P 1"));
    if (size(retcode["stderr"]:"")==0) 
	{
	discovered = ScanDiscovered( splitstring(retcode["stdout"]:"","\n") );
	}
 return discovered;
    }


global void startIScsid(){
 SCR::Execute(.target.bash, "pgrep iscsid || iscsid");
 foreach(integer i,[0,1,2,3,4,5,6,7,8,9],{
  sleep(1*1000);
  map<string, any> cmd=(map<string, any>)SCR::Execute(.target.bash_output, GetAdmCmd("-m session"));
  y2internal("iteration %1, retcode %2",i, cmd["exit"]:-1);
  if (cmd["exit"]:-1==0){
	y2internal("Good response from daemon, exit.");
	 break;
  }
 });
}

// get all connected targets
global boolean readSessions(){
 y2milestone("reading current settings");
  map<string, any> retcode = (map<string, any>)SCR::Execute(.target.bash_output, GetAdmCmd("-m session -P 1"));
  sessions = ScanDiscovered( splitstring(retcode["stdout"]:"", "\n") );
  y2milestone("Return list from iscsiadm -m session: %1", sessions);
 return true;
}

/**
 * write InitiatorName, create backup from previous if needed
 */
global boolean writeInitiatorName(string new_value){
 boolean ret=true;
 string file="/etc/iscsi/initiatorname.iscsi";
 if ( ((map<string, any>)SCR::Read (.target.lstat, file))["size"]:0>0 )
 {
   y2milestone("%1 file exists, create backup", file);
   SCR::Execute(.target.bash, sformat("mv %1 /etc/iscsi/initiatorname.yastbackup", file));
 }
 ret = (boolean)SCR::Write (.target.string, file, sformat("InitiatorName=%1\n", new_value));
 SCR::Execute (.target.bash, "chmod 0600 $FILE" ,$["FILE":file]);
 if (ret){
  initiatorname = new_value;
  y2milestone("Initiatorname %1 written", initiatorname);
 }
 // reload service when initiatorname is changed to re-read new value (bnc#482429)
 Service::Reload("open-iscsi");
 return ret;
}

string getReverseDomainName(){
 list<string> host_fq = Hostname::SplitFQ(((map<string,any>)SCR::Execute(.target.bash_output, "hostname -f|tr -d '\n'"))["stdout"]:"");
 y2internal("hostfw%1", host_fq);
 string domain = "";

 foreach(string item, splitstring(host_fq[1]:"example.com", "."),{
  y2internal("item %1", item);
  domain = (size(domain)==0) ? item : sformat("%1.%2", item, domain);
 });

 y2milestone("domain %1", domain);
 return domain;
}

// check initiatorname if exist, if no - create it
global boolean checkInitiatorName(){
 boolean ret=true;
 string file="/etc/iscsi/initiatorname.iscsi";
 string name_from_bios = getiBFT()["iface.initiatorname"]:"";
// if (size((map<string, any>)SCR::Read (.target.lstat, file)) == 0 || ((map<string, any>)SCR::Read (.target.lstat, file))["size"]:0==0){
    initiatorname=((map<string, any>)SCR::Execute(.target.bash_output,
			sformat("grep -v '^#' %1 | grep InitiatorName | cut -d'=' -f2 | tr -d '\n'", file)))["stdout"]:"";
// }
  if(size(initiatorname)==0){
   if (size(name_from_bios)>0){
    y2milestone("%1 is empty or doesnt exists - replace with name stored in iBFT", file);
    initiatorname = name_from_bios;
   } else {
	y2milestone("InitiatorName does not exist - generate it");
	 string domain = ((map<string,any>)SCR::Execute(.target.bash_output, ""))["stdout"]:"com.example";
	 map<string, any> output = (map<string, any>)SCR::Execute (.target.bash_output,
		sformat("/sbin/iscsi-iname -p iqn.%1.%2:01 | tr -d '\n'","`date +%Y-%m`", getReverseDomainName()), $[]);
	 if (size(output["stderr"]:"")==0){
	  initiatorname=output["stdout"]:"";
	} else ret = false;
    }
  ret = writeInitiatorName(initiatorname);
 } else {
    y2internal("initiatorname=%1", initiatorname);
   if (size(name_from_bios)>0 && name_from_bios!=initiatorname)
   {
    Popup::Warning( _("InitiatorName from iBFT and from <tt>/etc/iscsi/initiatorname.iscsi</tt> differ.
The old initiatorname will be replaced by the value of iBFT and create a backup.
If you want to use a different initiatorname, change it in the BIOS.") );
    y2milestone("replacing old name %1 by name %2 from iBFT", initiatorname, name_from_bios);
    initiatorname = name_from_bios;
    ret = writeInitiatorName(initiatorname);
   }
  }
 return ret;
}


// delete deiscovered target from database
global boolean deleteRecord(){
 boolean ret = true;
 y2milestone("Delete record %1", currentRecord);

    map<string, any> retcode = (map<string, any>)SCR::Execute(.target.bash_output, GetAdmCmd(sformat("-m node -I %3 -T %1 -p %2 --logout", 
                                                                                                     currentRecord[1]:"", currentRecord[0]:"",
												     currentRecord[2]:"default")));
        if (size(retcode["stderr"]:"")>0) return false;

 readSessions();
 return ret;
}

// get (manual/onboot) status of target connecting
global string getStartupStatus(){
 string status = "";
 y2milestone("Getting status of record %1", currentRecord);
     map<string, any> retcode = (map<string, any>)SCR::Execute(.target.bash_output, GetAdmCmd(sformat("-m node -I %3 -T %1 -p %2", 
                                                                                                      currentRecord[1]:"", currentRecord[0]:"",
												      currentRecord[2]:"default")));
    if (size(retcode["stderr"]:"")>0) return "";
    foreach(string row, splitstring(retcode["stdout"]:"", "\n"), {
     if (issubstring(row, "node.conn[0].startup")){
	status = (splitstring(row, " "))[2]:"";
       break;
      }
    });
 y2milestone("Startup status for %1 is %2", currentRecord, status);
 return status;
}

// update authentication value
global boolean setValue(string name, string value){
 y2milestone("set %1  for record %2", name, currentRecord);
 string command = GetAdmCmd(sformat("-m node -I %3 -T %1 -p %2 --op=update --name=%4 --value=%5", 
                                    currentRecord[1]:"", currentRecord[0]:"", currentRecord[2]:"default",
				    name, value));
 boolean ret = true;
        map<string, any> retcode = (map<string, any>) SCR::Execute(.target.bash_output, command);
    if (size(retcode["stderr"]:"")>0) {
				y2error("%1", retcode["stderr"]:"");
				ret =  false;
				}
y2milestone("return value %1", ret);
 return ret;
}


// check if given target is connected
global boolean connected(boolean check_ip){
y2internal("check connected status for %1 with IP check:%2", currentRecord, check_ip);
 boolean ret = false;
 foreach(string row, sessions, {
 list<string> list_row = splitstring(row, " ");
  if (list_row[1]:"" == currentRecord[1]:"" && list_row[2]:"" == currentRecord[2]:"" &&
      (check_ip ? splitstring(list_row[0]:"", ",")[0]:"" == splitstring(currentRecord[0]:"", ",")[0]:"" : true)){
   ret = true;
   break;
  }
 });
 return ret;
}

// change startup status (manual/onboot) for target
global boolean setStartupStatus(string status){
 y2milestone("Set startup status for %1 to %2", currentRecord, status);
 boolean ret = true;
 map<string, any> retcode = (map<string, any>) SCR::Execute(.target.bash_output,
	GetAdmCmd(sformat("-m node -I%3 -T %1 -p %2 --op=update --name=node.conn[0].startup --value=%4", 
	                  currentRecord[1]:"", currentRecord[0]:"", currentRecord[2]:"default", status)));
    if (size(retcode["stderr"]:"")>0) return false;
	else retcode = (map<string, any>) SCR::Execute(.target.bash_output,
        GetAdmCmd(sformat("-m node -I %3 -T %1 -p %2 --op=update --name=node.startup --value=%4", 
	                  currentRecord[1]:"", currentRecord[0]:"", currentRecord[2]:"default", status)));

y2internal("retcode %1", retcode);
 return ret;
}

global boolean autoLogOn(){
y2milestone("begin of autoLogOn function");
 if (size(getiBFT())>0){
  y2milestone("Autologin into iBFT : %1", SCR::Execute(.target.bash_output, GetAdmCmd("-m fw -l")));
 }
 return true;
}


global boolean loginIntoTarget(map target){
 currentRecord = [target["portal"]:"", target["target"]:"",target["iface"]:""];
 if (target["authmethod"]:"None"!="None"){
  string user_in = target["username_in"]:"";
  string pass_in = target["password_in"]:"";
  if (size(user_in)>0 && size(pass_in)>0){
   setValue("node.session.auth.username_in", user_in);
   setValue("node.session.auth.password_in", pass_in);
  } else{
           setValue("node.session.auth.username_in", "");
           setValue("node.session.auth.password_in", "");
   }
  string user_out = target["username"]:"";
  string pass_out = target["password"]:"";
  if (size(user_out)>0 && size(pass_out)>0){
   setValue("node.session.auth.username", user_out);
   setValue("node.session.auth.password", pass_out);
   setValue("node.session.auth.authmethod", "CHAP");
  } else {
           setValue("node.session.auth.username", "");
           setValue("node.session.auth.password", "");
           setValue("node.session.auth.authmethod", "");
    }
 } else setValue("node.session.auth.authmethod", "None");

  map<string, any> output = (map<string, any>)SCR::Execute(.target.bash_output,
		GetAdmCmd(sformat("-m node -I %3 -T %1 -p %2 --login", 
		                  target["target"]:"", target["portal"]:"", target["iface"]:"")));
 y2internal("output %1", output);
// if (output["exit"]:-1==0){
  // set startup status to auto by default (bnc#400610)
  if (!Mode::autoinst()) setStartupStatus("onboot");
  return true;
/*
 } else {
	y2error("Error while Log-on into target : %1", output);
	return false;
	}
*/
}


// get status of open-iscsi
global boolean getServiceStatus(){
 boolean ret = true;
 if (Stage::initial()){
  ModuleLoading::Load("iscsi_tcp", "", "", "", false, true);
  // start daemon before
  startIScsid();

 } else {
  if (Service::Status("open-iscsi") == 0) serviceStatus=true;
  y2milestone("Service status = %1", serviceStatus);
  // if not enabled, start it manually
  if (!serviceStatus) Service::Start("open-iscsi");
 }
 return ret;
}

// set startup status of open-iscsi
global boolean setServiceStatus(){
 boolean ret = true;
// if disabled and no connected targets - stop it
// otherwise keep it running
 if (!GetStartService()){
	 readSessions();
	 if (size(sessions)==0) {
		 y2milestone("No active sessions - stopping service");
		 Service::Stop("open-iscsi");
		}
	}
 y2milestone("Status service for open-iscsi: %1", ret);
 return ret;
}


global boolean autoyastPrepare(){
 initiatorname = ay_settings["initiatorname"]:"";
 if (size(initiatorname)>0){
  string file="/etc/iscsi/initiatorname.iscsi";
  SCR::Write (.target.string, file, sformat("InitiatorName=%1\n", initiatorname));
  SCR::Execute (.target.bash, "chmod 0600 $FILE" ,$["FILE":file]);
 } else checkInitiatorName();
 // start daemon before
 startIScsid();
}

global boolean autoyastWrite(){
    // do discovery first
    list<string> portals = [];
    list<string> ifaces = [];
    string ifacepar = "";
    foreach(map target, ay_settings["targets"]:[], {
	string iface = target["iface"]:"default";
	if (!contains(ifaces, iface)){
	    if( size(ifacepar)>0 )
		ifacepar = ifacepar + " ";
	    ifacepar = ifacepar + "-I " + iface;
	    ifaces = add(ifaces, iface);
	}
    });
    if( size( filter( string s, ifaces, ``(s!="default")))>0 )
	{
	CallConfigScript();
	}
    foreach(map target, ay_settings["targets"]:[], {
    if (!contains(portals, target["portal"]:"")){
	SCR::Execute(.target.bash, 
	    GetAdmCmd(sformat("-m discovery %1 -t st -p %2", ifacepar, target["portal"]:"")));
	portals = add(portals, target["portal"]:"");
	}
    });
    foreach(map target, ay_settings["targets"]:[], {
	y2internal("login into target %1", target);
	loginIntoTarget(target);
	currentRecord = [target["portal"]:"", target["target"]:"", target["iface"]:""];
        setStartupStatus(target["startup"]:"manual");
	});
    return true;
    }

global string Overview(){
 string overview = _("Configuration summary...");
 if (size(ay_settings)>0){
   overview="";
   if (size(ay_settings["initiatorname"]:"")>0) overview = overview + "<p><b>Initiatorname: </b>" + ay_settings["initiatorname"]:"" + "</p>";
   if (size(ay_settings["targets"]:[])>0){
    foreach(map target, (list<map>)ay_settings["targets"]:[], {
     overview = overview + "<p>" + target["portal"]:""  + ", " + target["target"]:"" + ", " + target["iface"]:"" + ", " + target["startup"]:"" + "</p>";
    });
   }
 }
 return overview;
}

string InitOffloadCard()
    {
    string ret = "default";
    map<string, any> retcode = (map<string, any>)SCR::Execute(.target.bash_output, GetAdmCmd("-m node -P 1"));
    list<string> ifaces = [];
    if (size(retcode["stderr"]:"")==0) 
	{
	foreach( string s,  ScanDiscovered( splitstring(retcode["stdout"]:"","\n") ),
	    {
	    list<string> sl = splitstring( s, "  " );
	    if( size(sl[2]:"")>0 && !contains( ifaces, sl[2]:"" ))
		{
		ifaces = add( ifaces, sl[2]:"" );
		}
	    });
	}
    y2milestone( "InitOffloadCard ifaces:%1", ifaces );
    if( size(ifaces)>1 )
	ret = "all";
    else if( contains( iface_eth, ifaces[0]:"" ))
	ret = ifaces[0]:"default";
    y2milestone( "InitOffloadCard ret:%1", ret );
    return( ret );
    }

list<list<any> > offload = [
	[ "default", "default"+" "+_("(Software)"), [] ],
	[ "all", "all", [] ],
	[ "bnx2", "bnx2/bnx2i/bnx2x", [ "bnx2", "bnx2i", "bnx2x" ] ],
	[ "cxgb3", "cxgb3/cxgb3i", [ "cxgb3", "cxgb3i" ] ],
	[ "enic", "enic/cnic/fnic", [ "enic", "cnic", "fnic" ] ],
	[ "qla4xxx", "qla4xxx", [ "qla4xxx" ] ],
	[ "be2net", "be2net/be2iscsi", [ "be2net", "be2iscsi" ] ]
    ];

map<integer,list> offload_valid = nil;

void InitIfaceFile()
    {
    iface_file = $[];
    list<string> files = (list<string>)SCR::Read(.target.dir, "/etc/iscsi/ifaces");
    y2milestone( "files:%1", files );
    foreach( string file, files,
	{
	list<string> ls = splitstring( (string)SCR::Read(.target.string, "/etc/iscsi/ifaces/"+file), "\n" );
	y2milestone( "file:%1", file );
	y2milestone( "ls:%1", ls );
	ls = filter( string l, ls, ``(search(l,"iface.iscsi_ifacename")!=nil));
	y2milestone( "ls:%1", ls );
	if( size(ls)>0 )
	    iface_file[splitstring(deletechars(ls[0]:""," "),"=")[1]:""] = file;
	});
    y2milestone( "iface_file:%1", iface_file );
    }

global list<term> GetOffloadItems()
    {
    integer i=0;
    boolean init = false;
    if( offload_valid==nil )
	{
	init = true;
	InitIfaceFile();
	offload_valid = $[];
	list<map> cards = (list<map>)SCR::Read(.probe.netcard);
	list<map> hw_mods = maplist( map c, cards, 
	    {
	    y2milestone( "GetOffloadItems card:%1", c );
	    list<list> tmp = maplist( map m, c["drivers"]:[], 
	                              ``(flatten((list<list>)m["modules"]:[])));
	    return( $["modules":maplist( list ml, tmp, ``(ml[0]:"")),
	              "iface":c["dev_name"]:"",
		      "macaddr":c["resource","hwaddr",0,"addr"]:""]);
	    });
	y2milestone( "GetOffloadItems hw_mods:%1", hw_mods );
	integer idx = 0;
	foreach( list<any> l, offload, 
	    ``{
	    boolean valid = false;
	    list<string> mod = (list<string>)sort(l[2]:[]);
	    if( size(mod)>0 )
		{
		i=0;
		foreach( map hw, hw_mods, 
		    ``{
		    if( size(multiset::intersection(mod,(list<string>)sort(hw["modules"]:[])))>0 )
			offload_valid[idx] = add( offload_valid[idx]:[], 
						  [ hw["iface"]:"", hw["macaddr"]:"", hw["iface"]:""+"-"+hw["modules",0]:""] );
		    });
		}
	    idx = idx+1;
	    });
	map<string,map> offload_res = $[];
	string cmd = "";
	foreach( integer i, list eth, offload_valid,
	    {
	    offload_valid[i] = filter( list l, (list<list>)eth,
		{
		cmd = offboard_script + " " + l[0]:"";
		y2milestone( "GetOffloadItems cmd:%1", cmd );
		map out = (map) SCR::Execute (.target.bash_output, cmd );
		y2milestone( "GetOffloadItems iscsi_offload out:%1", out );
		offload_res[l[0]:""] = $[];
		offload_res[l[0]:"","exit"] = out["exit"]:1;
		list<string> sl = [];
		if( out["exit"]:1==0 )
		    {
		    sl = splitstring( out["stdout"]:"", " \n" );
		    offload_res[l[0]:"","hwaddr"] = sl[0]:"";
		    offload_res[l[0]:"","ntype"] = sl[1]:"";
		    }
		return out["exit"]:1==0 && size(sl[0]:"")>0;
		});
	    });
	y2milestone( "GetOffloadItems offload_res:%1", offload_res );
	y2milestone( "GetOffloadItems offload_valid:%1", offload_valid );
	foreach( integer i, list eth, offload_valid,
	    {
	    offload_valid[i] = maplist( list l, (list<list>)eth,
		{
		l[1] = offload_res[l[0]:"","hwaddr"]:"";
		return( l );
		});
	    });
	y2milestone( "GetOffloadItems offload_valid:%1", offload_valid );
	foreach( integer i, list eth, offload_valid,
	    {
	    offload_valid[i] = maplist( list l, (list<list>)eth,
		{
		cmd = "ifconfig " + l[0]:"";
		y2milestone( "GetOffloadItems cmd:%1", cmd );
		map out = (map) SCR::Execute (.target.bash_output, cmd );
		y2milestone( "GetOffloadItems out:%1", out );
		string line = filter( string ln, splitstring( out["stdout"]:"", "\n" ),
		                      ``(search(ln,"inet addr:")!=nil))[0]:"";
		y2milestone( "GetOffloadItems line:%1", line );
		string ipaddr = "unknown";
		if( size(line)>0 )
		    {
		    line = substring( line, search( line, "inet addr:")+10 );
		    y2milestone( "GetOffloadItems line:%1", line );
		    ipaddr = substring( line, 0, findfirstof( line, " \t" ) );
		    }
		l = add( l, ipaddr );
		return( l );
		});
	    });
	y2milestone( "GetOffloadItems offload_valid:%1", offload_valid );
	}
    map<string,string> entries = $[];
    foreach( integer i, list eth, offload_valid,
	{
	foreach( list l, (list<list>)eth,
	    {
	    if( size(l[0]:"")>0 )
		{
		string s = l[0]:"";
		if( size(l[1]:"" )>0 )
		    s = s + " - " + l[1]:"";
		s = s + " - " + offload[i,1]:"";
		entries[l[2]:""] = s;
		}
	    });
	});
    y2milestone( "GetOffloadItems entries:%1", entries );
    iface_eth = sort(maplist( string e, string val, entries, ``(e)));
    y2milestone( "GetOffloadItems eth:%1", iface_eth );
    if( init )
	{
	offload_card = InitOffloadCard();
	y2milestone( "GetOffloadItems offload_card:%1", offload_card );
	}
    list<term> ret = [ `item( `id(offload[0,0]:""), offload[0,1]:"", offload_card==offload[0,0]:"" )]; 
    if( size(offload_valid)>0 )
	ret = add( ret, `item( `id(offload[1,0]:""), offload[1,1]:"", offload_card==offload[1,0]:"" ) );
    ret = (list<term>)merge( ret, maplist( string e, iface_eth,
				           ``(`item( `id(e), entries[e]:"", 
					      offload_card==e ))));
    y2milestone( "GetOffloadItems ret:%1", ret );
    return( ret );
    }

list<string> GetDiscIfaces()
    {
    list<string> ret = [];
    if( GetOffloadCard()=="all" )
	{
	list<string> tl = maplist( term t, GetOffloadItems(), ``(argsof(t)[0,0]:""));
	y2milestone( "GetDiscIfaces:%1", tl );
	ret = filter( string s, tl, ``(s!="all"));
	}
    else
	ret = [ GetOffloadCard() ];
    y2milestone( "GetDiscIfaces:%1", ret );
    return( ret );
    }

void CallConfigScript()
    {
    list<string> sl = filter( string s, GetDiscIfaces(), ``(s!="default"));
    y2milestone( "CallConfigScript list:%1", sl );
    foreach( string s, sl, 
	{
	list hw = [];
	hw = maplist( integer i, list e, 
	              filter( integer i, list eth, offload_valid, ``(contains(flatten((list<list>)eth),s))),
		      ``(e))[0]:[];
	y2milestone( "CallConfigScript hw:%1", hw );
	hw = find( list l, (list<list>)hw, ``(l[2]:""==s));
	y2milestone( "CallConfigScript hw:%1", hw );
	if( hw != nil )
	    {
	    string cmd = offboard_script + " " + hw[0]:"";
	    y2milestone( "CallConfigScript cmd:%1", cmd );
	    map output = (map)SCR::Execute(.target.bash_output, cmd );
	    y2milestone( "CallConfigScript %1", output );
	    }
	});
    }

global string GetDiscoveryCmd( string ip, string port)
    {
    y2milestone( "GetDiscoveryCmd ip:%1 port:%2", ip, port);
    string command = "-m discovery -P 1";
    if( useISNS() )
	command = command + " -t isns";
    else
	{
	list<string> ifs = GetDiscIfaces();
	y2milestone( "ifs=%1", ifs );
	ifs = maplist( string s, ifs, ``("-I "+s));
	y2milestone( "ifs=%1", ifs );
	command = command + sformat( " -t st %3 -p %1:%2", ip, port, mergestring(ifs," "));
	}
    command = GetAdmCmd(command);
    y2milestone( "GetDiscoveryCmd %1", command );
    return( command );
    }


}
